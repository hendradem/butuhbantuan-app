"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-modal-sheet@4.4.0_motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/react-modal-sheet@4.4.0_motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/react-modal-sheet@4.4.0_motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/react-modal-sheet/dist/index.mjs":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-modal-sheet@4.4.0_motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/react-modal-sheet/dist/index.mjs ***!
  \*******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sheet: () => (/* binding */ Sheet2)\n/* harmony export */ });\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/.pnpm/next@15.0.3_@babel+core@7.28.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@15.0.3_@babel+core@7.28.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! motion/react */ \"(ssr)/../../node_modules/.pnpm/motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/motion/dist/es/framer-motion/dist/es/value/use-motion-value.mjs\");\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! motion/react */ \"(ssr)/../../node_modules/.pnpm/motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion.mjs\");\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! motion/react */ \"(ssr)/../../node_modules/.pnpm/motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/motion/dist/es/framer-motion/dist/es/value/use-transform.mjs\");\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! motion/react */ \"(ssr)/../../node_modules/.pnpm/motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/animate/index.mjs\");\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! motion/react */ \"(ssr)/../../node_modules/.pnpm/motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/motion/dist/es/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n/* harmony import */ var motion_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! motion/react */ \"(ssr)/../../node_modules/.pnpm/motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/motion/dist/es/framer-motion/dist/es/components/AnimatePresence/index.mjs\");\n/* harmony import */ var motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! motion */ \"(ssr)/../../node_modules/.pnpm/motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/transform.mjs\");\n\n\n\n\n\n// src/sheet.tsx\n\n// src/constants.ts\nvar MAX_HEIGHT = \"calc(100% - env(safe-area-inset-top) - 34px)\";\nvar IS_SSR = typeof window === \"undefined\";\nvar DEFAULT_TWEEN_CONFIG = {\n  ease: \"easeOut\",\n  duration: 0.2\n};\nvar REDUCED_MOTION_TWEEN_CONFIG = {\n  ease: \"linear\",\n  duration: 0.01\n};\nvar DEFAULT_DRAG_CLOSE_THRESHOLD = 0.6;\nvar DEFAULT_DRAG_VELOCITY_THRESHOLD = 500;\n\n// src/utils.ts\nfunction getSheetHeight(sheetRef) {\n  const sheetEl = sheetRef.current;\n  if (!sheetEl) {\n    console.warn(\n      \"Sheet height is not available because the sheet element is not mounted yet.\"\n    );\n    return 0;\n  }\n  return Math.round(sheetEl.getBoundingClientRect().height);\n}\nfunction getSnapPoints({\n  snapPointsProp,\n  sheetHeight\n}) {\n  const snapPointValues = snapPointsProp.map((point) => {\n    if (point > 0 && point <= 1) {\n      return Math.round(point * sheetHeight);\n    }\n    return point < 0 ? sheetHeight + point : point;\n  });\n  console.assert(\n    inDescendingOrder(snapPointValues) || sheetHeight === 0,\n    `Snap points need to be in descending order got: [${snapPointsProp.join(\", \")}]`\n  );\n  return snapPointValues;\n}\nfunction getClosestSnapPoint({\n  snapPoints,\n  currentY,\n  sheetHeight,\n  detent\n}) {\n  const snapInverse = snapPoints.map(\n    (p) => sheetHeight - Math.min(p, sheetHeight)\n  );\n  if (detent === \"content-height\" && !snapInverse.includes(0)) {\n    snapInverse.unshift(0);\n  }\n  const snapTo = getClosest(snapInverse, currentY);\n  const snapIndex = snapInverse.indexOf(snapTo);\n  const snapY = validateSnapTo({\n    snapTo: getClosest(snapInverse, currentY),\n    sheetHeight\n  });\n  return { snapY, snapIndex };\n}\nfunction getClosest(nums, goal) {\n  let closest = nums[0];\n  let minDifference = Math.abs(nums[0] - goal);\n  for (let i = 1; i < nums.length; i++) {\n    const difference = Math.abs(nums[i] - goal);\n    if (difference < minDifference) {\n      closest = nums[i];\n      minDifference = difference;\n    }\n  }\n  return closest;\n}\nfunction inDescendingOrder(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i + 1] > arr[i]) return false;\n  }\n  return true;\n}\nfunction getSnapY({\n  sheetHeight,\n  snapPoints,\n  snapIndex\n}) {\n  const snapPoint = snapPoints[snapIndex];\n  if (snapPoint === void 0) {\n    console.warn(\n      `Invalid snap index ${snapIndex}. Snap points are: [${snapPoints.join(\", \")}]`\n    );\n    return null;\n  }\n  const y = validateSnapTo({ snapTo: sheetHeight - snapPoint, sheetHeight });\n  return y;\n}\nfunction validateSnapTo({\n  snapTo,\n  sheetHeight\n}) {\n  if (snapTo < 0) {\n    console.warn(\n      `Snap point is out of bounds. Sheet height is ${sheetHeight} but snap point is ${sheetHeight + Math.abs(snapTo)}.`\n    );\n  }\n  return Math.max(Math.round(snapTo), 0);\n}\nfunction mergeRefs(refs) {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref) {\n        ref.current = value;\n      }\n    });\n  };\n}\nfunction isTouchDevice() {\n  if (IS_SSR) return false;\n  return \"ontouchstart\" in window || navigator.maxTouchPoints > 0;\n}\nfunction testPlatform(re) {\n  var _a;\n  return typeof window !== \"undefined\" && window.navigator != null ? re.test(\n    // @ts-expect-error\n    ((_a = window.navigator.userAgentData) == null ? void 0 : _a.platform) || window.navigator.platform\n  ) : false;\n}\nfunction cached(fn) {\n  let res = null;\n  return () => {\n    if (res == null) {\n      res = fn();\n    }\n    return res;\n  };\n}\nvar isMac = cached(function() {\n  return testPlatform(/^Mac/i);\n});\nvar isIPhone = cached(function() {\n  return testPlatform(/^iPhone/i);\n});\nvar isIPad = cached(function() {\n  return testPlatform(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;\n});\nvar isIOS = cached(function() {\n  return isIPhone() || isIPad();\n});\nvar SheetContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(\n  void 0\n);\nfunction useSheetContext() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SheetContext);\n  if (!context) throw new Error(\"Sheet context error\");\n  return context;\n}\nvar SheetScrollerContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(void 0);\nfunction SheetScrollerContextProvider({\n  children\n}) {\n  const sheetContext = useSheetContext();\n  const [disableDrag, setDisableDrag] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!!sheetContext.disableDrag);\n  function setDragEnabled() {\n    if (!sheetContext.disableDrag) setDisableDrag(false);\n  }\n  function setDragDisabled() {\n    if (!disableDrag) setDisableDrag(true);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    SheetScrollerContext.Provider,\n    {\n      value: { disableDrag, setDragEnabled, setDragDisabled }\n    },\n    children\n  );\n}\nfunction useSheetScrollerContext() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SheetScrollerContext);\n  if (!context) throw new Error(\"Sheet scroller context error\");\n  return context;\n}\n\n// src/styles.ts\nvar styles = {\n  wrapper: {\n    position: \"fixed\",\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    overflow: \"hidden\",\n    pointerEvents: \"none\"\n  },\n  backdrop: {\n    zIndex: 1,\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    backgroundColor: \"rgba(0, 0, 0, 0.2)\",\n    touchAction: \"none\",\n    border: \"none\",\n    userSelect: \"none\",\n    WebkitTapHighlightColor: \"transparent\"\n  },\n  container: {\n    zIndex: 2,\n    position: \"absolute\",\n    left: 0,\n    bottom: 0,\n    width: \"100%\",\n    backgroundColor: \"#fff\",\n    borderTopRightRadius: \"8px\",\n    borderTopLeftRadius: \"8px\",\n    boxShadow: \"0px -2px 16px rgba(0, 0, 0, 0.3)\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    pointerEvents: \"auto\"\n  },\n  headerWrapper: {\n    width: \"100%\"\n  },\n  header: {\n    height: \"40px\",\n    width: \"100%\",\n    position: \"relative\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\"\n  },\n  indicator: {\n    width: \"18px\",\n    height: \"4px\",\n    borderRadius: \"99px\",\n    backgroundColor: \"#ddd\"\n  },\n  content: {\n    flexGrow: 1,\n    display: \"flex\",\n    flexDirection: \"column\",\n    minHeight: \"0px\",\n    position: \"relative\"\n  },\n  scroller: {\n    height: \"100%\",\n    overflowY: \"auto\",\n    overscrollBehaviorY: \"none\"\n  }\n};\nvar useIsomorphicLayoutEffect = IS_SSR ? react__WEBPACK_IMPORTED_MODULE_1__.useEffect : react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect;\nfunction useSafeAreaInsets() {\n  const [insets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => {\n    const fallback = { top: 0, left: 0, right: 0, bottom: 0 };\n    if (IS_SSR) return fallback;\n    const root = document.querySelector(\":root\");\n    if (!root) return fallback;\n    root.style.setProperty(\"--rms-sat\", \"env(safe-area-inset-top)\");\n    root.style.setProperty(\"--rms-sal\", \"env(safe-area-inset-left)\");\n    root.style.setProperty(\"--rms-sar\", \"env(safe-area-inset-right)\");\n    root.style.setProperty(\"--rms-sab\", \"env(safe-area-inset-bottom)\");\n    const computedStyle = getComputedStyle(root);\n    const sat = getComputedValue(computedStyle, \"--rms-sat\");\n    const sal = getComputedValue(computedStyle, \"--rms-sal\");\n    const sar = getComputedValue(computedStyle, \"--rms-sar\");\n    const sab = getComputedValue(computedStyle, \"--rms-sab\");\n    root.style.removeProperty(\"--rms-sat\");\n    root.style.removeProperty(\"--rms-sal\");\n    root.style.removeProperty(\"--rms-sar\");\n    root.style.removeProperty(\"--rms-sab\");\n    return { top: sat, left: sal, right: sar, bottom: sab };\n  });\n  return insets;\n}\nfunction getComputedValue(computed, property) {\n  const strValue = computed.getPropertyValue(property).replace(\"px\", \"\").trim();\n  return parseInt(strValue, 10) || 0;\n}\n\n// src/hooks/use-modal-effect.ts\nfunction useModalEffect({\n  y,\n  rootId,\n  sheetRef,\n  snapPointsProp,\n  startThreshold\n}) {\n  const insetTop = useSafeAreaInsets().top;\n  useIsomorphicLayoutEffect(() => {\n    return () => {\n      if (rootId) cleanupModalEffect(rootId);\n    };\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    if (!rootId) return;\n    const root = document.querySelector(`#${rootId}`);\n    if (!root) return;\n    let sheetHeight = 0;\n    const removeStartListener = y.on(\"animationStart\", () => {\n      sheetHeight = getSheetHeight(sheetRef);\n      setupModalEffect(rootId);\n    });\n    const removeChangeListener = y.on(\"change\", (yValue) => {\n      if (!root) return;\n      let progress = Math.max(0, 1 - yValue / sheetHeight);\n      const snapPoints = snapPointsProp ? getSnapPoints({ snapPointsProp, sheetHeight }) : void 0;\n      const snapThresholdPoint = snapPoints && snapPoints.length > 1 ? snapPoints[1] : void 0;\n      if (snapThresholdPoint !== void 0) {\n        const snapThresholdValue = sheetHeight - Math.min(snapThresholdPoint, sheetHeight);\n        if (yValue <= snapThresholdValue) {\n          progress = (snapThresholdValue - yValue) / snapThresholdValue;\n        } else {\n          progress = 0;\n        }\n      }\n      if (startThreshold !== void 0) {\n        const startThresholdValue = sheetHeight - Math.min(Math.floor(startThreshold * sheetHeight), sheetHeight);\n        if (yValue <= startThresholdValue) {\n          progress = (startThresholdValue - yValue) / startThresholdValue;\n        } else {\n          progress = 0;\n        }\n      }\n      progress = Math.max(0, Math.min(1, progress));\n      const pageWidth = window.innerWidth;\n      const ty = (0,motion__WEBPACK_IMPORTED_MODULE_2__.transform)(progress, [0, 1], [0, 24 + insetTop]);\n      const s = (0,motion__WEBPACK_IMPORTED_MODULE_2__.transform)(progress, [0, 1], [1, (pageWidth - 16) / pageWidth]);\n      const borderRadius = (0,motion__WEBPACK_IMPORTED_MODULE_2__.transform)(progress, [0, 1], [0, 10]);\n      root.style.transform = `scale(${s}) translate3d(0, ${ty}px, 0)`;\n      root.style.borderTopRightRadius = `${borderRadius}px`;\n      root.style.borderTopLeftRadius = `${borderRadius}px`;\n    });\n    function onCompleted() {\n      if (y.get() - 5 >= sheetHeight) {\n        cleanupModalEffect(rootId);\n      }\n    }\n    const removeCompleteListener = y.on(\"animationComplete\", onCompleted);\n    const removeCancelListener = y.on(\"animationCancel\", onCompleted);\n    return () => {\n      removeStartListener();\n      removeChangeListener();\n      removeCompleteListener();\n      removeCancelListener();\n    };\n  }, [y, rootId, insetTop, startThreshold, snapPointsProp]);\n}\nfunction setupModalEffect(rootId) {\n  const root = document.querySelector(`#${rootId}`);\n  const body = document.querySelector(\"body\");\n  if (!root) return;\n  body.style.backgroundColor = \"#000\";\n  root.style.overflow = \"hidden\";\n  root.style.transitionTimingFunction = \"cubic-bezier(0.32, 0.72, 0, 1)\";\n  root.style.transitionProperty = \"transform, border-radius\";\n  root.style.transitionDuration = \"0.5s\";\n  root.style.transformOrigin = \"center top\";\n}\nfunction cleanupModalEffect(rootId) {\n  const root = document.querySelector(`#${rootId}`);\n  const body = document.querySelector(\"body\");\n  if (!root) return;\n  body.style.removeProperty(\"background-color\");\n  root.style.removeProperty(\"overflow\");\n  root.style.removeProperty(\"transition-timing-function\");\n  root.style.removeProperty(\"transition-property\");\n  root.style.removeProperty(\"transition-duration\");\n  root.style.removeProperty(\"transform-origin\");\n  root.style.removeProperty(\"transform\");\n  root.style.removeProperty(\"border-top-right-radius\");\n  root.style.removeProperty(\"border-top-left-radius\");\n}\nfunction useDimensions() {\n  const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => ({\n    height: !IS_SSR ? window.innerHeight : 0,\n    width: !IS_SSR ? window.innerWidth : 0\n  }));\n  useIsomorphicLayoutEffect(() => {\n    function handler() {\n      setDimensions({\n        height: window.innerHeight,\n        width: window.innerWidth\n      });\n    }\n    handler();\n    window.addEventListener(\"resize\", handler);\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n  return dimensions;\n}\nfunction useStableCallback(handler) {\n  const handlerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(void 0);\n  useIsomorphicLayoutEffect(() => {\n    handlerRef.current = handler;\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((...args) => {\n    const fn = handlerRef.current;\n    return fn == null ? void 0 : fn(...args);\n  }, []);\n}\n\n// src/hooks/use-prevent-scroll.ts\nvar KEYBOARD_BUFFER = 24;\nfunction chain(...callbacks) {\n  return (...args) => {\n    for (const callback of callbacks) {\n      if (typeof callback === \"function\") {\n        callback(...args);\n      }\n    }\n  };\n}\nvar visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction isScrollable(node, checkForOverflow) {\n  if (!node) {\n    return false;\n  }\n  const style = window.getComputedStyle(node);\n  let isScrollable2 = /(auto|scroll)/.test(\n    style.overflow + style.overflowX + style.overflowY\n  );\n  if (isScrollable2 && checkForOverflow) {\n    isScrollable2 = node.scrollHeight !== node.clientHeight || node.scrollWidth !== node.clientWidth;\n  }\n  return isScrollable2;\n}\nfunction getScrollParent(node, checkForOverflow) {\n  let scrollableNode = node;\n  if (isScrollable(scrollableNode, checkForOverflow)) {\n    scrollableNode = scrollableNode.parentElement;\n  }\n  while (scrollableNode && !isScrollable(scrollableNode, checkForOverflow)) {\n    scrollableNode = scrollableNode.parentElement;\n  }\n  return scrollableNode || document.scrollingElement || document.documentElement;\n}\nvar nonTextInputTypes = /* @__PURE__ */ new Set([\n  \"checkbox\",\n  \"radio\",\n  \"range\",\n  \"color\",\n  \"file\",\n  \"image\",\n  \"button\",\n  \"submit\",\n  \"reset\"\n]);\nvar preventScrollCount = 0;\nvar restore;\nfunction usePreventScroll(options = {}) {\n  const { isDisabled } = options;\n  useIsomorphicLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore == null ? void 0 : restore();\n      }\n    };\n  }, [isDisabled]);\n}\nfunction preventScrollStandard() {\n  return chain(\n    setStyle(\n      document.documentElement,\n      \"paddingRight\",\n      `${window.innerWidth - document.documentElement.clientWidth}px`\n    ),\n    setStyle(document.documentElement, \"overflow\", \"hidden\")\n  );\n}\nfunction preventScrollMobileSafari() {\n  let scrollable;\n  let lastY = 0;\n  const onTouchStart = (e) => {\n    var _a;\n    const target = (_a = e.composedPath()) == null ? void 0 : _a[0];\n    scrollable = getScrollParent(target, true);\n    if (scrollable === document.documentElement && scrollable === document.body) {\n      return;\n    }\n    lastY = e.changedTouches[0].pageY;\n  };\n  const onTouchMove = (e) => {\n    if (scrollable === void 0) {\n      return;\n    }\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n    const y = e.changedTouches[0].pageY;\n    const scrollTop = scrollable.scrollTop;\n    const bottom = scrollable.scrollHeight - scrollable.clientHeight;\n    if (bottom === 0) {\n      return;\n    }\n    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {\n      e.preventDefault();\n    }\n    lastY = y;\n  };\n  const onTouchEnd = (e) => {\n    var _a;\n    const target = (_a = e.composedPath()) == null ? void 0 : _a[0];\n    if (willOpenKeyboard(target) && target !== document.activeElement) {\n      e.preventDefault();\n      target.style.transform = \"translateY(-2000px)\";\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = \"\";\n      });\n    }\n  };\n  const onFocus = (e) => {\n    var _a;\n    const target = (_a = e.composedPath()) == null ? void 0 : _a[0];\n    if (willOpenKeyboard(target)) {\n      target.style.transform = \"translateY(-2000px)\";\n      requestAnimationFrame(() => {\n        target.style.transform = \"\";\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            visualViewport.addEventListener(\n              \"resize\",\n              () => scrollIntoView(target),\n              { once: true }\n            );\n          }\n        }\n      });\n    }\n  };\n  const onWindowScroll = () => {\n    window.scrollTo(0, 0);\n  };\n  const scrollX = window.pageXOffset;\n  const scrollY = window.pageYOffset;\n  const restoreStyles = chain(\n    setStyle(\n      document.documentElement,\n      \"paddingRight\",\n      `${window.innerWidth - document.documentElement.clientWidth}px`\n    ),\n    setStyle(document.documentElement, \"overflow\", \"hidden\"),\n    setStyle(document.body, \"marginTop\", `-${scrollY}px`)\n  );\n  window.scrollTo(0, 0);\n  const removeEvents = chain(\n    addEvent(document, \"touchstart\", onTouchStart, {\n      passive: false,\n      capture: true\n    }),\n    addEvent(document, \"touchmove\", onTouchMove, {\n      passive: false,\n      capture: true\n    }),\n    addEvent(document, \"touchend\", onTouchEnd, {\n      passive: false,\n      capture: true\n    }),\n    addEvent(document, \"focus\", onFocus, true),\n    addEvent(window, \"scroll\", onWindowScroll)\n  );\n  return () => {\n    restoreStyles();\n    removeEvents();\n    window.scrollTo(scrollX, scrollY);\n  };\n}\nfunction setStyle(element, style, value) {\n  const cur = element.style[style];\n  element.style[style] = value;\n  return () => {\n    element.style[style] = cur;\n  };\n}\nfunction addEvent(target, event, handler, options) {\n  target.addEventListener(event, handler, options);\n  return () => {\n    target.removeEventListener(event, handler, options);\n  };\n}\nfunction scrollIntoView(target) {\n  const root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    const scrollable = getScrollParent(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      const scrollableTop = scrollable.getBoundingClientRect().top;\n      const targetTop = target.getBoundingClientRect().top;\n      const targetBottom = target.getBoundingClientRect().bottom;\n      const keyboardHeight = scrollable.getBoundingClientRect().bottom + KEYBOARD_BUFFER;\n      if (targetBottom > keyboardHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n    target = scrollable.parentElement;\n  }\n}\nfunction willOpenKeyboard(target) {\n  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n\n// src/sheet.tsx\nvar Sheet = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({\n    onOpenStart,\n    onOpenEnd,\n    onClose,\n    onCloseStart,\n    onCloseEnd,\n    onSnap,\n    children,\n    disableScrollLocking = false,\n    isOpen,\n    snapPoints: snapPointsProp,\n    rootId,\n    modalEffectRootId,\n    mountPoint,\n    style,\n    detent = \"full-height\",\n    initialSnap = 0,\n    disableDrag = false,\n    prefersReducedMotion = false,\n    tweenConfig = DEFAULT_TWEEN_CONFIG,\n    dragVelocityThreshold = DEFAULT_DRAG_VELOCITY_THRESHOLD,\n    dragCloseThreshold = DEFAULT_DRAG_CLOSE_THRESHOLD,\n    modalEffectThreshold,\n    ...rest\n  }, ref) => {\n    const sheetRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const indicatorRotation = (0,motion_react__WEBPACK_IMPORTED_MODULE_3__.useMotionValue)(0);\n    const { height: windowHeight } = useDimensions();\n    const shouldReduceMotion = (0,motion_react__WEBPACK_IMPORTED_MODULE_4__.useReducedMotion)();\n    const reduceMotion = Boolean(prefersReducedMotion || shouldReduceMotion);\n    const animationOptions = {\n      type: \"tween\",\n      ...reduceMotion ? REDUCED_MOTION_TWEEN_CONFIG : tweenConfig\n    };\n    const y = (0,motion_react__WEBPACK_IMPORTED_MODULE_3__.useMotionValue)(windowHeight);\n    const zIndex = (0,motion_react__WEBPACK_IMPORTED_MODULE_5__.useTransform)(\n      y,\n      (value) => value + 2 >= windowHeight ? -1 : (style == null ? void 0 : style.zIndex) ?? 9999\n    );\n    const visibility = (0,motion_react__WEBPACK_IMPORTED_MODULE_5__.useTransform)(\n      y,\n      (value) => value + 2 >= windowHeight ? \"hidden\" : \"visible\"\n    );\n    const callbacks = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n      onOpenStart,\n      onOpenEnd,\n      onCloseStart,\n      onCloseEnd\n    });\n    useIsomorphicLayoutEffect(() => {\n      callbacks.current = {\n        onOpenStart,\n        onOpenEnd,\n        onCloseStart,\n        onCloseEnd\n      };\n    });\n    const onDrag = useStableCallback((_, info) => {\n      const currentY = y.get();\n      if (snapPointsProp) {\n        const sheetHeight = getSheetHeight(sheetRef);\n        const snapPoints = getSnapPoints({ snapPointsProp, sheetHeight });\n        const topSnapPoint = sheetHeight - snapPoints[0];\n        if (info.delta.y < 0 && currentY <= topSnapPoint) {\n          y.set(topSnapPoint);\n          return;\n        }\n      }\n      const velocity = y.getVelocity();\n      if (velocity > 0) indicatorRotation.set(10);\n      if (velocity < 0) indicatorRotation.set(-10);\n      y.set(Math.max(currentY + info.delta.y, 0));\n    });\n    const onDragStart = useStableCallback(() => {\n      const focusedElement = document.activeElement;\n      if (!focusedElement || !sheetRef.current) return;\n      const isInput = focusedElement.tagName === \"INPUT\" || focusedElement.tagName === \"TEXTAREA\";\n      if (isInput && sheetRef.current.contains(focusedElement)) {\n        focusedElement.blur();\n      }\n    });\n    const onDragEnd = useStableCallback((_, { velocity }) => {\n      if (velocity.y > dragVelocityThreshold) {\n        onClose();\n      } else {\n        const sheetHeight = getSheetHeight(sheetRef);\n        const currentY = y.get();\n        let yTo = 0;\n        const snapPoints = snapPointsProp ? getSnapPoints({ snapPointsProp, sheetHeight }) : void 0;\n        if (snapPoints) {\n          const { snapY, snapIndex } = getClosestSnapPoint({\n            snapPoints,\n            currentY,\n            sheetHeight,\n            detent\n          });\n          yTo = snapY;\n          onSnap == null ? void 0 : onSnap(snapIndex);\n        } else if (currentY / sheetHeight > dragCloseThreshold) {\n          yTo = sheetHeight;\n        }\n        (0,motion_react__WEBPACK_IMPORTED_MODULE_6__.animate)(y, yTo, animationOptions);\n        if (yTo + 1 >= sheetHeight) {\n          onClose();\n        }\n      }\n      indicatorRotation.set(0);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      if (snapPointsProp && onSnap) {\n        onSnap(isOpen ? initialSnap : snapPointsProp.length - 1);\n      }\n    }, [isOpen]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      if (!isOpen) return;\n      let yTo = 0;\n      if (snapPointsProp) {\n        const snapIndex = initialSnap;\n        const sheetHeight = getSheetHeight(sheetRef);\n        const snapPoints = getSnapPoints({ snapPointsProp, sheetHeight });\n        const snapY = getSnapY({ sheetHeight, snapPoints, snapIndex });\n        if (snapY !== null) {\n          yTo = snapY;\n        }\n      }\n      (0,motion_react__WEBPACK_IMPORTED_MODULE_6__.animate)(y, yTo, animationOptions);\n    }, [isOpen]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, () => ({\n      y,\n      snapTo: (snapIndex) => {\n        if (!snapPointsProp) {\n          console.warn(\"Snapping is not possible without `snapPoints` prop.\");\n          return;\n        }\n        const sheetHeight = getSheetHeight(sheetRef);\n        const snapPoints = getSnapPoints({ snapPointsProp, sheetHeight });\n        const snapY = getSnapY({ sheetHeight, snapPoints, snapIndex });\n        if (snapY !== null) {\n          (0,motion_react__WEBPACK_IMPORTED_MODULE_6__.animate)(y, snapY, animationOptions);\n          onSnap == null ? void 0 : onSnap(snapIndex);\n          if (snapY + 1 >= sheetHeight) {\n            onClose();\n          }\n        }\n      }\n    }));\n    if (rootId) {\n      console.warn(\n        \"The `rootId` prop is deprecated and will be removed in the next major version. Use `modalEffectRootId` instead.\"\n      );\n    }\n    useModalEffect({\n      y,\n      sheetRef,\n      snapPointsProp,\n      rootId: rootId || modalEffectRootId,\n      startThreshold: modalEffectThreshold\n    });\n    usePreventScroll({\n      isDisabled: disableScrollLocking || !isOpen\n    });\n    const dragProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n      const dragProps2 = {\n        drag: \"y\",\n        dragElastic: 0,\n        dragMomentum: false,\n        dragPropagation: false,\n        onDrag,\n        onDragStart,\n        onDragEnd\n      };\n      return disableDrag ? void 0 : dragProps2;\n    }, [disableDrag, windowHeight]);\n    const context = {\n      y,\n      sheetRef,\n      isOpen,\n      initialSnap,\n      detent,\n      indicatorRotation,\n      callbacks,\n      dragProps,\n      windowHeight,\n      animationOptions,\n      reduceMotion,\n      disableDrag\n    };\n    const sheet = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(SheetContext.Provider, { value: context }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.div,\n      {\n        ...rest,\n        ref,\n        style: { ...styles.wrapper, zIndex, visibility, ...style }\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(motion_react__WEBPACK_IMPORTED_MODULE_8__.AnimatePresence, null, isOpen ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(SheetScrollerContextProvider, null, react__WEBPACK_IMPORTED_MODULE_1__.Children.map(\n        children,\n        (child, i) => (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(child, { key: `sheet-child-${i}` })\n      )) : null)\n    ));\n    if (IS_SSR) return sheet;\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_0__.createPortal)(sheet, mountPoint ?? document.body);\n  }\n);\nSheet.displayName = \"Sheet\";\nfunction useEventCallbacks(isOpen, callbacks) {\n  const prevOpen = usePrevious(isOpen);\n  const didOpen = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  const handleAnimationComplete = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    var _a, _b, _c, _d;\n    if (!didOpen.current) {\n      (_b = (_a = callbacks.current).onOpenEnd) == null ? void 0 : _b.call(_a);\n      didOpen.current = true;\n    } else {\n      (_d = (_c = callbacks.current).onCloseEnd) == null ? void 0 : _d.call(_c);\n      didOpen.current = false;\n    }\n  }, [isOpen, prevOpen]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var _a, _b, _c, _d;\n    if (!prevOpen && isOpen) {\n      (_b = (_a = callbacks.current).onOpenStart) == null ? void 0 : _b.call(_a);\n    } else if (!isOpen && prevOpen) {\n      (_d = (_c = callbacks.current).onCloseStart) == null ? void 0 : _d.call(_c);\n    }\n  }, [isOpen, prevOpen]);\n  return { handleAnimationComplete };\n}\nfunction usePrevious(state) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(void 0);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ref.current = state;\n  });\n  return ref.current;\n}\n\n// src/SheetContainer.tsx\nvar SheetContainer = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ children, style, className = \"\", ...rest }, ref) => {\n    const {\n      y,\n      isOpen,\n      callbacks,\n      sheetRef,\n      windowHeight,\n      detent,\n      animationOptions\n    } = useSheetContext();\n    const { handleAnimationComplete } = useEventCallbacks(isOpen, callbacks);\n    const height = detent === \"full-height\" ? MAX_HEIGHT : void 0;\n    const maxHeight = detent === \"content-height\" ? MAX_HEIGHT : void 0;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.div,\n      {\n        ...rest,\n        ref: mergeRefs([sheetRef, ref]),\n        className: `react-modal-sheet-container ${className}`,\n        style: { ...styles.container, height, maxHeight, ...style, y },\n        initial: { y: windowHeight },\n        exit: { y: windowHeight, transition: animationOptions },\n        onAnimationComplete: handleAnimationComplete\n      },\n      children\n    );\n  }\n);\nSheetContainer.displayName = \"SheetContainer\";\nvar constraints = { bottom: 0, top: 0, left: 0, right: 0 };\nfunction useDragConstraints() {\n  const constraintsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const onMeasureDragConstraints = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => constraints, []);\n  return { constraintsRef, onMeasureDragConstraints };\n}\n\n// src/SheetContent.tsx\nvar SheetContent = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ children, style, disableDrag, className = \"\", ...rest }, ref) => {\n    const sheetContext = useSheetContext();\n    const sheetScrollerContext = useSheetScrollerContext();\n    const { constraintsRef, onMeasureDragConstraints } = useDragConstraints();\n    const dragProps = disableDrag || sheetScrollerContext.disableDrag ? void 0 : sheetContext.dragProps;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.div,\n      {\n        ...rest,\n        ref: mergeRefs([ref, constraintsRef]),\n        className: `react-modal-sheet-content ${className}`,\n        style: { ...styles.content, ...style },\n        ...dragProps,\n        dragConstraints: constraintsRef,\n        onMeasureDragConstraints\n      },\n      children\n    );\n  }\n);\nSheetContent.displayName = \"SheetContent\";\nvar SheetHeader = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ children, style, disableDrag, ...rest }, ref) => {\n    const { indicatorRotation, dragProps } = useSheetContext();\n    const { constraintsRef, onMeasureDragConstraints } = useDragConstraints();\n    const _dragProps = disableDrag ? void 0 : dragProps;\n    const indicator1Transform = (0,motion_react__WEBPACK_IMPORTED_MODULE_5__.useTransform)(\n      indicatorRotation,\n      (r) => `translateX(2px) rotate(${r}deg)`\n    );\n    const indicator2Transform = (0,motion_react__WEBPACK_IMPORTED_MODULE_5__.useTransform)(\n      indicatorRotation,\n      (r) => `translateX(-2px) rotate(${ -1 * r}deg)`\n    );\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.div,\n      {\n        ...rest,\n        ref: mergeRefs([ref, constraintsRef]),\n        style: { ...styles.headerWrapper, ...style },\n        ..._dragProps,\n        dragConstraints: constraintsRef,\n        onMeasureDragConstraints\n      },\n      children || /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: \"react-modal-sheet-header\", style: styles.header }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.span,\n        {\n          className: \"react-modal-sheet-drag-indicator\",\n          style: { ...styles.indicator, transform: indicator1Transform }\n        }\n      ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.span,\n        {\n          className: \"react-modal-sheet-drag-indicator\",\n          style: { ...styles.indicator, transform: indicator2Transform }\n        }\n      ))\n    );\n  }\n);\nSheetHeader.displayName = \"SheetHeader\";\nvar isClickable = (props) => !!props.onClick || !!props.onTap;\nvar SheetBackdrop = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({ style = {}, className = \"\", ...rest }, ref) => {\n    const Comp = isClickable(rest) ? motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.button : motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.div;\n    const pointerEvents = isClickable(rest) ? \"auto\" : \"none\";\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      Comp,\n      {\n        ...rest,\n        ref,\n        className: `react-modal-sheet-backdrop ${className}`,\n        style: { ...styles.backdrop, ...style, pointerEvents },\n        initial: { opacity: 0 },\n        animate: { opacity: 1 },\n        exit: { opacity: 0 }\n      }\n    );\n  }\n);\nSheetBackdrop.displayName = \"SheetBackdrop\";\nvar SheetScroller = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(\n  ({\n    autoPadding = true,\n    disableScroll = false,\n    draggableAt = \"top\",\n    children,\n    style: styleProp,\n    className = \"\",\n    ...rest\n  }, ref) => {\n    const { y } = useSheetContext();\n    const { setDragEnabled, setDragDisabled } = useSheetScrollerContext();\n    function determineDragState(element) {\n      if (disableScroll) {\n        setDragEnabled();\n        return;\n      }\n      const { scrollTop, scrollHeight, clientHeight } = element;\n      const isScrollable2 = scrollHeight > clientHeight;\n      if (!isScrollable2) return;\n      const isAtTop = scrollTop <= 0;\n      const isAtBottom = scrollHeight - scrollTop === clientHeight;\n      const shouldEnable = draggableAt === \"top\" && isAtTop || draggableAt === \"bottom\" && isAtBottom || draggableAt === \"both\" && (isAtTop || isAtBottom);\n      if (shouldEnable) {\n        setDragEnabled();\n      } else {\n        setDragDisabled();\n      }\n    }\n    function onScroll(event) {\n      determineDragState(event.currentTarget);\n      if (rest.onScroll) rest.onScroll(event);\n    }\n    function onTouchStart(event) {\n      determineDragState(event.currentTarget);\n      if (rest.onTouchStart) rest.onTouchStart(event);\n    }\n    const scrollProps = isTouchDevice() ? { onScroll, onTouchStart } : void 0;\n    const style = {\n      ...styles.scroller,\n      ...styleProp\n    };\n    if (autoPadding) {\n      style.paddingBottom = y;\n    }\n    if (disableScroll) {\n      style.overflowY = \"hidden\";\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      motion_react__WEBPACK_IMPORTED_MODULE_7__.motion.div,\n      {\n        ...rest,\n        ref,\n        className: `react-modal-sheet-scroller ${className}`,\n        style,\n        ...scrollProps\n      },\n      children\n    );\n  }\n);\nSheetScroller.displayName = \"SheetScroller\";\n\n// src/index.tsx\nvar Sheet2 = Object.assign(Sheet, {\n  Container: SheetContainer,\n  Header: SheetHeader,\n  Content: SheetContent,\n  Backdrop: SheetBackdrop,\n  Scroller: SheetScroller\n});\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LW1vZGFsLXNoZWV0QDQuNC4wX21vdGlvbkAxMi4xOC4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwtc2hlZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF5QztBQUM4STtBQUN2RTtBQUM3RTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3REFBd0QsMEJBQTBCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSxzQkFBc0Isc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBOEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esc0RBQXNELGFBQWEsb0JBQW9CLCtCQUEr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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLElBQUk7QUFDaEIsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFvQjtBQUMvQyxNQUFNLGdEQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFMEI7QUFDM0I7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhaHl1L0RvY3VtZW50cy9EZXYvUHJvamVjdHMvYnV0dWhiYW50dWFuLW1vbm9yZXBvL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1tb2RhbC1zaGVldEA0LjQuMF9tb3Rpb25AMTIuMTguMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsLXNoZWV0L2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUmVhY3QyLCB7IGNyZWF0ZUNvbnRleHQsIGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZU1lbW8sIENoaWxkcmVuLCBjbG9uZUVsZW1lbnQsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU1vdGlvblZhbHVlLCB1c2VSZWR1Y2VkTW90aW9uLCB1c2VUcmFuc2Zvcm0sIGFuaW1hdGUsIG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnbW90aW9uL3JlYWN0JztcbmltcG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gJ21vdGlvbic7XG5cbi8vIHNyYy9zaGVldC50c3hcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIE1BWF9IRUlHSFQgPSBcImNhbGMoMTAwJSAtIGVudihzYWZlLWFyZWEtaW5zZXQtdG9wKSAtIDM0cHgpXCI7XG52YXIgSVNfU1NSID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcbnZhciBERUZBVUxUX1RXRUVOX0NPTkZJRyA9IHtcbiAgZWFzZTogXCJlYXNlT3V0XCIsXG4gIGR1cmF0aW9uOiAwLjJcbn07XG52YXIgUkVEVUNFRF9NT1RJT05fVFdFRU5fQ09ORklHID0ge1xuICBlYXNlOiBcImxpbmVhclwiLFxuICBkdXJhdGlvbjogMC4wMVxufTtcbnZhciBERUZBVUxUX0RSQUdfQ0xPU0VfVEhSRVNIT0xEID0gMC42O1xudmFyIERFRkFVTFRfRFJBR19WRUxPQ0lUWV9USFJFU0hPTEQgPSA1MDA7XG5cbi8vIHNyYy91dGlscy50c1xuZnVuY3Rpb24gZ2V0U2hlZXRIZWlnaHQoc2hlZXRSZWYpIHtcbiAgY29uc3Qgc2hlZXRFbCA9IHNoZWV0UmVmLmN1cnJlbnQ7XG4gIGlmICghc2hlZXRFbCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiU2hlZXQgaGVpZ2h0IGlzIG5vdCBhdmFpbGFibGUgYmVjYXVzZSB0aGUgc2hlZXQgZWxlbWVudCBpcyBub3QgbW91bnRlZCB5ZXQuXCJcbiAgICApO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKHNoZWV0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbn1cbmZ1bmN0aW9uIGdldFNuYXBQb2ludHMoe1xuICBzbmFwUG9pbnRzUHJvcCxcbiAgc2hlZXRIZWlnaHRcbn0pIHtcbiAgY29uc3Qgc25hcFBvaW50VmFsdWVzID0gc25hcFBvaW50c1Byb3AubWFwKChwb2ludCkgPT4ge1xuICAgIGlmIChwb2ludCA+IDAgJiYgcG9pbnQgPD0gMSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQocG9pbnQgKiBzaGVldEhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludCA8IDAgPyBzaGVldEhlaWdodCArIHBvaW50IDogcG9pbnQ7XG4gIH0pO1xuICBjb25zb2xlLmFzc2VydChcbiAgICBpbkRlc2NlbmRpbmdPcmRlcihzbmFwUG9pbnRWYWx1ZXMpIHx8IHNoZWV0SGVpZ2h0ID09PSAwLFxuICAgIGBTbmFwIHBvaW50cyBuZWVkIHRvIGJlIGluIGRlc2NlbmRpbmcgb3JkZXIgZ290OiBbJHtzbmFwUG9pbnRzUHJvcC5qb2luKFwiLCBcIil9XWBcbiAgKTtcbiAgcmV0dXJuIHNuYXBQb2ludFZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldENsb3Nlc3RTbmFwUG9pbnQoe1xuICBzbmFwUG9pbnRzLFxuICBjdXJyZW50WSxcbiAgc2hlZXRIZWlnaHQsXG4gIGRldGVudFxufSkge1xuICBjb25zdCBzbmFwSW52ZXJzZSA9IHNuYXBQb2ludHMubWFwKFxuICAgIChwKSA9PiBzaGVldEhlaWdodCAtIE1hdGgubWluKHAsIHNoZWV0SGVpZ2h0KVxuICApO1xuICBpZiAoZGV0ZW50ID09PSBcImNvbnRlbnQtaGVpZ2h0XCIgJiYgIXNuYXBJbnZlcnNlLmluY2x1ZGVzKDApKSB7XG4gICAgc25hcEludmVyc2UudW5zaGlmdCgwKTtcbiAgfVxuICBjb25zdCBzbmFwVG8gPSBnZXRDbG9zZXN0KHNuYXBJbnZlcnNlLCBjdXJyZW50WSk7XG4gIGNvbnN0IHNuYXBJbmRleCA9IHNuYXBJbnZlcnNlLmluZGV4T2Yoc25hcFRvKTtcbiAgY29uc3Qgc25hcFkgPSB2YWxpZGF0ZVNuYXBUbyh7XG4gICAgc25hcFRvOiBnZXRDbG9zZXN0KHNuYXBJbnZlcnNlLCBjdXJyZW50WSksXG4gICAgc2hlZXRIZWlnaHRcbiAgfSk7XG4gIHJldHVybiB7IHNuYXBZLCBzbmFwSW5kZXggfTtcbn1cbmZ1bmN0aW9uIGdldENsb3Nlc3QobnVtcywgZ29hbCkge1xuICBsZXQgY2xvc2VzdCA9IG51bXNbMF07XG4gIGxldCBtaW5EaWZmZXJlbmNlID0gTWF0aC5hYnMobnVtc1swXSAtIGdvYWwpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMobnVtc1tpXSAtIGdvYWwpO1xuICAgIGlmIChkaWZmZXJlbmNlIDwgbWluRGlmZmVyZW5jZSkge1xuICAgICAgY2xvc2VzdCA9IG51bXNbaV07XG4gICAgICBtaW5EaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5mdW5jdGlvbiBpbkRlc2NlbmRpbmdPcmRlcihhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2kgKyAxXSA+IGFycltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0U25hcFkoe1xuICBzaGVldEhlaWdodCxcbiAgc25hcFBvaW50cyxcbiAgc25hcEluZGV4XG59KSB7XG4gIGNvbnN0IHNuYXBQb2ludCA9IHNuYXBQb2ludHNbc25hcEluZGV4XTtcbiAgaWYgKHNuYXBQb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEludmFsaWQgc25hcCBpbmRleCAke3NuYXBJbmRleH0uIFNuYXAgcG9pbnRzIGFyZTogWyR7c25hcFBvaW50cy5qb2luKFwiLCBcIil9XWBcbiAgICApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHkgPSB2YWxpZGF0ZVNuYXBUbyh7IHNuYXBUbzogc2hlZXRIZWlnaHQgLSBzbmFwUG9pbnQsIHNoZWV0SGVpZ2h0IH0pO1xuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU25hcFRvKHtcbiAgc25hcFRvLFxuICBzaGVldEhlaWdodFxufSkge1xuICBpZiAoc25hcFRvIDwgMCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBTbmFwIHBvaW50IGlzIG91dCBvZiBib3VuZHMuIFNoZWV0IGhlaWdodCBpcyAke3NoZWV0SGVpZ2h0fSBidXQgc25hcCBwb2ludCBpcyAke3NoZWV0SGVpZ2h0ICsgTWF0aC5hYnMoc25hcFRvKX0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgucm91bmQoc25hcFRvKSwgMCk7XG59XG5mdW5jdGlvbiBtZXJnZVJlZnMocmVmcykge1xuICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc1RvdWNoRGV2aWNlKCkge1xuICBpZiAoSVNfU1NSKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xufVxuZnVuY3Rpb24gdGVzdFBsYXRmb3JtKHJlKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hdmlnYXRvciAhPSBudWxsID8gcmUudGVzdChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgKChfYSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50RGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtXG4gICkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlZChmbikge1xuICBsZXQgcmVzID0gbnVsbDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgIHJlcyA9IGZuKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG52YXIgaXNNYWMgPSBjYWNoZWQoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0ZXN0UGxhdGZvcm0oL15NYWMvaSk7XG59KTtcbnZhciBpc0lQaG9uZSA9IGNhY2hlZChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRlc3RQbGF0Zm9ybSgvXmlQaG9uZS9pKTtcbn0pO1xudmFyIGlzSVBhZCA9IGNhY2hlZChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRlc3RQbGF0Zm9ybSgvXmlQYWQvaSkgfHwgaXNNYWMoKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xufSk7XG52YXIgaXNJT1MgPSBjYWNoZWQoZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpc0lQaG9uZSgpIHx8IGlzSVBhZCgpO1xufSk7XG52YXIgU2hlZXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgdm9pZCAwXG4pO1xuZnVuY3Rpb24gdXNlU2hlZXRDb250ZXh0KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChTaGVldENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBFcnJvcihcIlNoZWV0IGNvbnRleHQgZXJyb3JcIik7XG4gIHJldHVybiBjb250ZXh0O1xufVxudmFyIFNoZWV0U2Nyb2xsZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gU2hlZXRTY3JvbGxlckNvbnRleHRQcm92aWRlcih7XG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IHNoZWV0Q29udGV4dCA9IHVzZVNoZWV0Q29udGV4dCgpO1xuICBjb25zdCBbZGlzYWJsZURyYWcsIHNldERpc2FibGVEcmFnXSA9IHVzZVN0YXRlKCEhc2hlZXRDb250ZXh0LmRpc2FibGVEcmFnKTtcbiAgZnVuY3Rpb24gc2V0RHJhZ0VuYWJsZWQoKSB7XG4gICAgaWYgKCFzaGVldENvbnRleHQuZGlzYWJsZURyYWcpIHNldERpc2FibGVEcmFnKGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBzZXREcmFnRGlzYWJsZWQoKSB7XG4gICAgaWYgKCFkaXNhYmxlRHJhZykgc2V0RGlzYWJsZURyYWcodHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICBTaGVldFNjcm9sbGVyQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogeyBkaXNhYmxlRHJhZywgc2V0RHJhZ0VuYWJsZWQsIHNldERyYWdEaXNhYmxlZCB9XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuZnVuY3Rpb24gdXNlU2hlZXRTY3JvbGxlckNvbnRleHQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFNoZWV0U2Nyb2xsZXJDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoXCJTaGVldCBzY3JvbGxlciBjb250ZXh0IGVycm9yXCIpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuLy8gc3JjL3N0eWxlcy50c1xudmFyIHN0eWxlcyA9IHtcbiAgd3JhcHBlcjoge1xuICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gIH0sXG4gIGJhY2tkcm9wOiB7XG4gICAgekluZGV4OiAxLFxuICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4yKVwiLFxuICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcbiAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgfSxcbiAgY29udGFpbmVyOiB7XG4gICAgekluZGV4OiAyLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgbGVmdDogMCxcbiAgICBib3R0b206IDAsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmZmXCIsXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IFwiOHB4XCIsXG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogXCI4cHhcIixcbiAgICBib3hTaGFkb3c6IFwiMHB4IC0ycHggMTZweCByZ2JhKDAsIDAsIDAsIDAuMylcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gIH0sXG4gIGhlYWRlcldyYXBwZXI6IHtcbiAgICB3aWR0aDogXCIxMDAlXCJcbiAgfSxcbiAgaGVhZGVyOiB7XG4gICAgaGVpZ2h0OiBcIjQwcHhcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiXG4gIH0sXG4gIGluZGljYXRvcjoge1xuICAgIHdpZHRoOiBcIjE4cHhcIixcbiAgICBoZWlnaHQ6IFwiNHB4XCIsXG4gICAgYm9yZGVyUmFkaXVzOiBcIjk5cHhcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2RkZFwiXG4gIH0sXG4gIGNvbnRlbnQ6IHtcbiAgICBmbGV4R3JvdzogMSxcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIG1pbkhlaWdodDogXCIwcHhcIixcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG4gIH0sXG4gIHNjcm9sbGVyOiB7XG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBvdmVyZmxvd1k6IFwiYXV0b1wiLFxuICAgIG92ZXJzY3JvbGxCZWhhdmlvclk6IFwibm9uZVwiXG4gIH1cbn07XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IElTX1NTUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbmZ1bmN0aW9uIHVzZVNhZmVBcmVhSW5zZXRzKCkge1xuICBjb25zdCBbaW5zZXRzXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICBjb25zdCBmYWxsYmFjayA9IHsgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XG4gICAgaWYgKElTX1NTUikgcmV0dXJuIGZhbGxiYWNrO1xuICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOnJvb3RcIik7XG4gICAgaWYgKCFyb290KSByZXR1cm4gZmFsbGJhY2s7XG4gICAgcm9vdC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm1zLXNhdFwiLCBcImVudihzYWZlLWFyZWEtaW5zZXQtdG9wKVwiKTtcbiAgICByb290LnN0eWxlLnNldFByb3BlcnR5KFwiLS1ybXMtc2FsXCIsIFwiZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0KVwiKTtcbiAgICByb290LnN0eWxlLnNldFByb3BlcnR5KFwiLS1ybXMtc2FyXCIsIFwiZW52KHNhZmUtYXJlYS1pbnNldC1yaWdodClcIik7XG4gICAgcm9vdC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm1zLXNhYlwiLCBcImVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tKVwiKTtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcbiAgICBjb25zdCBzYXQgPSBnZXRDb21wdXRlZFZhbHVlKGNvbXB1dGVkU3R5bGUsIFwiLS1ybXMtc2F0XCIpO1xuICAgIGNvbnN0IHNhbCA9IGdldENvbXB1dGVkVmFsdWUoY29tcHV0ZWRTdHlsZSwgXCItLXJtcy1zYWxcIik7XG4gICAgY29uc3Qgc2FyID0gZ2V0Q29tcHV0ZWRWYWx1ZShjb21wdXRlZFN0eWxlLCBcIi0tcm1zLXNhclwiKTtcbiAgICBjb25zdCBzYWIgPSBnZXRDb21wdXRlZFZhbHVlKGNvbXB1dGVkU3R5bGUsIFwiLS1ybXMtc2FiXCIpO1xuICAgIHJvb3Quc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLXJtcy1zYXRcIik7XG4gICAgcm9vdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIi0tcm1zLXNhbFwiKTtcbiAgICByb290LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS1ybXMtc2FyXCIpO1xuICAgIHJvb3Quc3R5bGUucmVtb3ZlUHJvcGVydHkoXCItLXJtcy1zYWJcIik7XG4gICAgcmV0dXJuIHsgdG9wOiBzYXQsIGxlZnQ6IHNhbCwgcmlnaHQ6IHNhciwgYm90dG9tOiBzYWIgfTtcbiAgfSk7XG4gIHJldHVybiBpbnNldHM7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFZhbHVlKGNvbXB1dGVkLCBwcm9wZXJ0eSkge1xuICBjb25zdCBzdHJWYWx1ZSA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpLnJlcGxhY2UoXCJweFwiLCBcIlwiKS50cmltKCk7XG4gIHJldHVybiBwYXJzZUludChzdHJWYWx1ZSwgMTApIHx8IDA7XG59XG5cbi8vIHNyYy9ob29rcy91c2UtbW9kYWwtZWZmZWN0LnRzXG5mdW5jdGlvbiB1c2VNb2RhbEVmZmVjdCh7XG4gIHksXG4gIHJvb3RJZCxcbiAgc2hlZXRSZWYsXG4gIHNuYXBQb2ludHNQcm9wLFxuICBzdGFydFRocmVzaG9sZFxufSkge1xuICBjb25zdCBpbnNldFRvcCA9IHVzZVNhZmVBcmVhSW5zZXRzKCkudG9wO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHJvb3RJZCkgY2xlYW51cE1vZGFsRWZmZWN0KHJvb3RJZCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXJvb3RJZCkgcmV0dXJuO1xuICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtyb290SWR9YCk7XG4gICAgaWYgKCFyb290KSByZXR1cm47XG4gICAgbGV0IHNoZWV0SGVpZ2h0ID0gMDtcbiAgICBjb25zdCByZW1vdmVTdGFydExpc3RlbmVyID0geS5vbihcImFuaW1hdGlvblN0YXJ0XCIsICgpID0+IHtcbiAgICAgIHNoZWV0SGVpZ2h0ID0gZ2V0U2hlZXRIZWlnaHQoc2hlZXRSZWYpO1xuICAgICAgc2V0dXBNb2RhbEVmZmVjdChyb290SWQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlbW92ZUNoYW5nZUxpc3RlbmVyID0geS5vbihcImNoYW5nZVwiLCAoeVZhbHVlKSA9PiB7XG4gICAgICBpZiAoIXJvb3QpIHJldHVybjtcbiAgICAgIGxldCBwcm9ncmVzcyA9IE1hdGgubWF4KDAsIDEgLSB5VmFsdWUgLyBzaGVldEhlaWdodCk7XG4gICAgICBjb25zdCBzbmFwUG9pbnRzID0gc25hcFBvaW50c1Byb3AgPyBnZXRTbmFwUG9pbnRzKHsgc25hcFBvaW50c1Byb3AsIHNoZWV0SGVpZ2h0IH0pIDogdm9pZCAwO1xuICAgICAgY29uc3Qgc25hcFRocmVzaG9sZFBvaW50ID0gc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCA+IDEgPyBzbmFwUG9pbnRzWzFdIDogdm9pZCAwO1xuICAgICAgaWYgKHNuYXBUaHJlc2hvbGRQb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNuYXBUaHJlc2hvbGRWYWx1ZSA9IHNoZWV0SGVpZ2h0IC0gTWF0aC5taW4oc25hcFRocmVzaG9sZFBvaW50LCBzaGVldEhlaWdodCk7XG4gICAgICAgIGlmICh5VmFsdWUgPD0gc25hcFRocmVzaG9sZFZhbHVlKSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSAoc25hcFRocmVzaG9sZFZhbHVlIC0geVZhbHVlKSAvIHNuYXBUaHJlc2hvbGRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydFRocmVzaG9sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGhyZXNob2xkVmFsdWUgPSBzaGVldEhlaWdodCAtIE1hdGgubWluKE1hdGguZmxvb3Ioc3RhcnRUaHJlc2hvbGQgKiBzaGVldEhlaWdodCksIHNoZWV0SGVpZ2h0KTtcbiAgICAgICAgaWYgKHlWYWx1ZSA8PSBzdGFydFRocmVzaG9sZFZhbHVlKSB7XG4gICAgICAgICAgcHJvZ3Jlc3MgPSAoc3RhcnRUaHJlc2hvbGRWYWx1ZSAtIHlWYWx1ZSkgLyBzdGFydFRocmVzaG9sZFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2dyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwcm9ncmVzcykpO1xuICAgICAgY29uc3QgcGFnZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCB0eSA9IHRyYW5zZm9ybShwcm9ncmVzcywgWzAsIDFdLCBbMCwgMjQgKyBpbnNldFRvcF0pO1xuICAgICAgY29uc3QgcyA9IHRyYW5zZm9ybShwcm9ncmVzcywgWzAsIDFdLCBbMSwgKHBhZ2VXaWR0aCAtIDE2KSAvIHBhZ2VXaWR0aF0pO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdHJhbnNmb3JtKHByb2dyZXNzLCBbMCwgMV0sIFswLCAxMF0pO1xuICAgICAgcm9vdC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzfSkgdHJhbnNsYXRlM2QoMCwgJHt0eX1weCwgMClgO1xuICAgICAgcm9vdC5zdHlsZS5ib3JkZXJUb3BSaWdodFJhZGl1cyA9IGAke2JvcmRlclJhZGl1c31weGA7XG4gICAgICByb290LnN0eWxlLmJvcmRlclRvcExlZnRSYWRpdXMgPSBgJHtib3JkZXJSYWRpdXN9cHhgO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG9uQ29tcGxldGVkKCkge1xuICAgICAgaWYgKHkuZ2V0KCkgLSA1ID49IHNoZWV0SGVpZ2h0KSB7XG4gICAgICAgIGNsZWFudXBNb2RhbEVmZmVjdChyb290SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZW1vdmVDb21wbGV0ZUxpc3RlbmVyID0geS5vbihcImFuaW1hdGlvbkNvbXBsZXRlXCIsIG9uQ29tcGxldGVkKTtcbiAgICBjb25zdCByZW1vdmVDYW5jZWxMaXN0ZW5lciA9IHkub24oXCJhbmltYXRpb25DYW5jZWxcIiwgb25Db21wbGV0ZWQpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZW1vdmVTdGFydExpc3RlbmVyKCk7XG4gICAgICByZW1vdmVDaGFuZ2VMaXN0ZW5lcigpO1xuICAgICAgcmVtb3ZlQ29tcGxldGVMaXN0ZW5lcigpO1xuICAgICAgcmVtb3ZlQ2FuY2VsTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9LCBbeSwgcm9vdElkLCBpbnNldFRvcCwgc3RhcnRUaHJlc2hvbGQsIHNuYXBQb2ludHNQcm9wXSk7XG59XG5mdW5jdGlvbiBzZXR1cE1vZGFsRWZmZWN0KHJvb3RJZCkge1xuICBjb25zdCByb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7cm9vdElkfWApO1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJvZHlcIik7XG4gIGlmICghcm9vdCkgcmV0dXJuO1xuICBib2R5LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiIzAwMFwiO1xuICByb290LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgcm9vdC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBcImN1YmljLWJlemllcigwLjMyLCAwLjcyLCAwLCAxKVwiO1xuICByb290LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IFwidHJhbnNmb3JtLCBib3JkZXItcmFkaXVzXCI7XG4gIHJvb3Quc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCIwLjVzXCI7XG4gIHJvb3Quc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJjZW50ZXIgdG9wXCI7XG59XG5mdW5jdGlvbiBjbGVhbnVwTW9kYWxFZmZlY3Qocm9vdElkKSB7XG4gIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtyb290SWR9YCk7XG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKTtcbiAgaWYgKCFyb290KSByZXR1cm47XG4gIGJvZHkuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpO1xuICByb290LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3ZlcmZsb3dcIik7XG4gIHJvb3Quc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiKTtcbiAgcm9vdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zaXRpb24tcHJvcGVydHlcIik7XG4gIHJvb3Quc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIpO1xuICByb290LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidHJhbnNmb3JtLW9yaWdpblwiKTtcbiAgcm9vdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zZm9ybVwiKTtcbiAgcm9vdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIpO1xuICByb290LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiKTtcbn1cbmZ1bmN0aW9uIHVzZURpbWVuc2lvbnMoKSB7XG4gIGNvbnN0IFtkaW1lbnNpb25zLCBzZXREaW1lbnNpb25zXSA9IHVzZVN0YXRlKCgpID0+ICh7XG4gICAgaGVpZ2h0OiAhSVNfU1NSID8gd2luZG93LmlubmVySGVpZ2h0IDogMCxcbiAgICB3aWR0aDogIUlTX1NTUiA/IHdpbmRvdy5pbm5lcldpZHRoIDogMFxuICB9KSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICBzZXREaW1lbnNpb25zKHtcbiAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZXIoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gZGltZW5zaW9ucztcbn1cbmZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpIHtcbiAgY29uc3QgaGFuZGxlclJlZiA9IHVzZVJlZih2b2lkIDApO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSBoYW5kbGVyO1xuICB9KTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgZm4gPSBoYW5kbGVyUmVmLmN1cnJlbnQ7XG4gICAgcmV0dXJuIGZuID09IG51bGwgPyB2b2lkIDAgOiBmbiguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXByZXZlbnQtc2Nyb2xsLnRzXG52YXIgS0VZQk9BUkRfQlVGRkVSID0gMjQ7XG5mdW5jdGlvbiBjaGFpbiguLi5jYWxsYmFja3MpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgdmlzdWFsVmlld3BvcnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnZpc3VhbFZpZXdwb3J0O1xuZnVuY3Rpb24gaXNTY3JvbGxhYmxlKG5vZGUsIGNoZWNrRm9yT3ZlcmZsb3cpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGxldCBpc1Njcm9sbGFibGUyID0gLyhhdXRvfHNjcm9sbCkvLnRlc3QoXG4gICAgc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1ggKyBzdHlsZS5vdmVyZmxvd1lcbiAgKTtcbiAgaWYgKGlzU2Nyb2xsYWJsZTIgJiYgY2hlY2tGb3JPdmVyZmxvdykge1xuICAgIGlzU2Nyb2xsYWJsZTIgPSBub2RlLnNjcm9sbEhlaWdodCAhPT0gbm9kZS5jbGllbnRIZWlnaHQgfHwgbm9kZS5zY3JvbGxXaWR0aCAhPT0gbm9kZS5jbGllbnRXaWR0aDtcbiAgfVxuICByZXR1cm4gaXNTY3JvbGxhYmxlMjtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlLCBjaGVja0Zvck92ZXJmbG93KSB7XG4gIGxldCBzY3JvbGxhYmxlTm9kZSA9IG5vZGU7XG4gIGlmIChpc1Njcm9sbGFibGUoc2Nyb2xsYWJsZU5vZGUsIGNoZWNrRm9yT3ZlcmZsb3cpKSB7XG4gICAgc2Nyb2xsYWJsZU5vZGUgPSBzY3JvbGxhYmxlTm9kZS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHdoaWxlIChzY3JvbGxhYmxlTm9kZSAmJiAhaXNTY3JvbGxhYmxlKHNjcm9sbGFibGVOb2RlLCBjaGVja0Zvck92ZXJmbG93KSkge1xuICAgIHNjcm9sbGFibGVOb2RlID0gc2Nyb2xsYWJsZU5vZGUucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gc2Nyb2xsYWJsZU5vZGUgfHwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG52YXIgbm9uVGV4dElucHV0VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY2hlY2tib3hcIixcbiAgXCJyYWRpb1wiLFxuICBcInJhbmdlXCIsXG4gIFwiY29sb3JcIixcbiAgXCJmaWxlXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJidXR0b25cIixcbiAgXCJzdWJtaXRcIixcbiAgXCJyZXNldFwiXG5dKTtcbnZhciBwcmV2ZW50U2Nyb2xsQ291bnQgPSAwO1xudmFyIHJlc3RvcmU7XG5mdW5jdGlvbiB1c2VQcmV2ZW50U2Nyb2xsKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGlzRGlzYWJsZWQgfSA9IG9wdGlvbnM7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZXZlbnRTY3JvbGxDb3VudCsrO1xuICAgIGlmIChwcmV2ZW50U2Nyb2xsQ291bnQgPT09IDEpIHtcbiAgICAgIGlmIChpc0lPUygpKSB7XG4gICAgICAgIHJlc3RvcmUgPSBwcmV2ZW50U2Nyb2xsTW9iaWxlU2FmYXJpKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0b3JlID0gcHJldmVudFNjcm9sbFN0YW5kYXJkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwcmV2ZW50U2Nyb2xsQ291bnQtLTtcbiAgICAgIGlmIChwcmV2ZW50U2Nyb2xsQ291bnQgPT09IDApIHtcbiAgICAgICAgcmVzdG9yZSA9PSBudWxsID8gdm9pZCAwIDogcmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc0Rpc2FibGVkXSk7XG59XG5mdW5jdGlvbiBwcmV2ZW50U2Nyb2xsU3RhbmRhcmQoKSB7XG4gIHJldHVybiBjaGFpbihcbiAgICBzZXRTdHlsZShcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIFwicGFkZGluZ1JpZ2h0XCIsXG4gICAgICBgJHt3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aH1weGBcbiAgICApLFxuICAgIHNldFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKVxuICApO1xufVxuZnVuY3Rpb24gcHJldmVudFNjcm9sbE1vYmlsZVNhZmFyaSgpIHtcbiAgbGV0IHNjcm9sbGFibGU7XG4gIGxldCBsYXN0WSA9IDA7XG4gIGNvbnN0IG9uVG91Y2hTdGFydCA9IChlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRhcmdldCA9IChfYSA9IGUuY29tcG9zZWRQYXRoKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXTtcbiAgICBzY3JvbGxhYmxlID0gZ2V0U2Nyb2xsUGFyZW50KHRhcmdldCwgdHJ1ZSk7XG4gICAgaWYgKHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBzY3JvbGxhYmxlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RZID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgfTtcbiAgY29uc3Qgb25Ub3VjaE1vdmUgPSAoZSkgPT4ge1xuICAgIGlmIChzY3JvbGxhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzY3JvbGxhYmxlIHx8IHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBzY3JvbGxhYmxlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbGFibGUuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsYWJsZS5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKGJvdHRvbSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2Nyb2xsVG9wIDw9IDAgJiYgeSA+IGxhc3RZIHx8IHNjcm9sbFRvcCA+PSBib3R0b20gJiYgeSA8IGxhc3RZKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGxhc3RZID0geTtcbiAgfTtcbiAgY29uc3Qgb25Ub3VjaEVuZCA9IChlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRhcmdldCA9IChfYSA9IGUuY29tcG9zZWRQYXRoKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXTtcbiAgICBpZiAod2lsbE9wZW5LZXlib2FyZCh0YXJnZXQpICYmIHRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgtMjAwMHB4KVwiO1xuICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gXCJcIjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25Gb2N1cyA9IChlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRhcmdldCA9IChfYSA9IGUuY29tcG9zZWRQYXRoKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXTtcbiAgICBpZiAod2lsbE9wZW5LZXlib2FyZCh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKC0yMDAwcHgpXCI7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gXCJcIjtcbiAgICAgICAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICAgICAgaWYgKHZpc3VhbFZpZXdwb3J0LmhlaWdodCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBcInJlc2l6ZVwiLFxuICAgICAgICAgICAgICAoKSA9PiBzY3JvbGxJbnRvVmlldyh0YXJnZXQpLFxuICAgICAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25XaW5kb3dTY3JvbGwgPSAoKSA9PiB7XG4gICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICB9O1xuICBjb25zdCBzY3JvbGxYID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICBjb25zdCBzY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICBjb25zdCByZXN0b3JlU3R5bGVzID0gY2hhaW4oXG4gICAgc2V0U3R5bGUoXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgYCR7d2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh9cHhgXG4gICAgKSxcbiAgICBzZXRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIiksXG4gICAgc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgXCJtYXJnaW5Ub3BcIiwgYC0ke3Njcm9sbFl9cHhgKVxuICApO1xuICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gIGNvbnN0IHJlbW92ZUV2ZW50cyA9IGNoYWluKFxuICAgIGFkZEV2ZW50KGRvY3VtZW50LCBcInRvdWNoc3RhcnRcIiwgb25Ub3VjaFN0YXJ0LCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KSxcbiAgICBhZGRFdmVudChkb2N1bWVudCwgXCJ0b3VjaG1vdmVcIiwgb25Ub3VjaE1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLFxuICAgIGFkZEV2ZW50KGRvY3VtZW50LCBcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLFxuICAgIGFkZEV2ZW50KGRvY3VtZW50LCBcImZvY3VzXCIsIG9uRm9jdXMsIHRydWUpLFxuICAgIGFkZEV2ZW50KHdpbmRvdywgXCJzY3JvbGxcIiwgb25XaW5kb3dTY3JvbGwpXG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmVzdG9yZVN0eWxlcygpO1xuICAgIHJlbW92ZUV2ZW50cygpO1xuICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlKGVsZW1lbnQsIHN0eWxlLCB2YWx1ZSkge1xuICBjb25zdCBjdXIgPSBlbGVtZW50LnN0eWxlW3N0eWxlXTtcbiAgZWxlbWVudC5zdHlsZVtzdHlsZV0gPSB2YWx1ZTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnN0eWxlW3N0eWxlXSA9IGN1cjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KHRhcmdldCkge1xuICBjb25zdCByb290ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSByb290KSB7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZSA9IGdldFNjcm9sbFBhcmVudCh0YXJnZXQpO1xuICAgIGlmIChzY3JvbGxhYmxlICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgc2Nyb2xsYWJsZSAhPT0gZG9jdW1lbnQuYm9keSAmJiBzY3JvbGxhYmxlICE9PSB0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHNjcm9sbGFibGVUb3AgPSBzY3JvbGxhYmxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgIGNvbnN0IHRhcmdldFRvcCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICBjb25zdCB0YXJnZXRCb3R0b20gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgY29uc3Qga2V5Ym9hcmRIZWlnaHQgPSBzY3JvbGxhYmxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSArIEtFWUJPQVJEX0JVRkZFUjtcbiAgICAgIGlmICh0YXJnZXRCb3R0b20gPiBrZXlib2FyZEhlaWdodCkge1xuICAgICAgICBzY3JvbGxhYmxlLnNjcm9sbFRvcCArPSB0YXJnZXRUb3AgLSBzY3JvbGxhYmxlVG9wO1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXQgPSBzY3JvbGxhYmxlLnBhcmVudEVsZW1lbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpbGxPcGVuS2V5Ym9hcmQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmICFub25UZXh0SW5wdXRUeXBlcy5oYXModGFyZ2V0LnR5cGUpIHx8IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlO1xufVxuXG4vLyBzcmMvc2hlZXQudHN4XG52YXIgU2hlZXQgPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIG9uT3BlblN0YXJ0LFxuICAgIG9uT3BlbkVuZCxcbiAgICBvbkNsb3NlLFxuICAgIG9uQ2xvc2VTdGFydCxcbiAgICBvbkNsb3NlRW5kLFxuICAgIG9uU25hcCxcbiAgICBjaGlsZHJlbixcbiAgICBkaXNhYmxlU2Nyb2xsTG9ja2luZyA9IGZhbHNlLFxuICAgIGlzT3BlbixcbiAgICBzbmFwUG9pbnRzOiBzbmFwUG9pbnRzUHJvcCxcbiAgICByb290SWQsXG4gICAgbW9kYWxFZmZlY3RSb290SWQsXG4gICAgbW91bnRQb2ludCxcbiAgICBzdHlsZSxcbiAgICBkZXRlbnQgPSBcImZ1bGwtaGVpZ2h0XCIsXG4gICAgaW5pdGlhbFNuYXAgPSAwLFxuICAgIGRpc2FibGVEcmFnID0gZmFsc2UsXG4gICAgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSBmYWxzZSxcbiAgICB0d2VlbkNvbmZpZyA9IERFRkFVTFRfVFdFRU5fQ09ORklHLFxuICAgIGRyYWdWZWxvY2l0eVRocmVzaG9sZCA9IERFRkFVTFRfRFJBR19WRUxPQ0lUWV9USFJFU0hPTEQsXG4gICAgZHJhZ0Nsb3NlVGhyZXNob2xkID0gREVGQVVMVF9EUkFHX0NMT1NFX1RIUkVTSE9MRCxcbiAgICBtb2RhbEVmZmVjdFRocmVzaG9sZCxcbiAgICAuLi5yZXN0XG4gIH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IHNoZWV0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGluZGljYXRvclJvdGF0aW9uID0gdXNlTW90aW9uVmFsdWUoMCk7XG4gICAgY29uc3QgeyBoZWlnaHQ6IHdpbmRvd0hlaWdodCB9ID0gdXNlRGltZW5zaW9ucygpO1xuICAgIGNvbnN0IHNob3VsZFJlZHVjZU1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb24oKTtcbiAgICBjb25zdCByZWR1Y2VNb3Rpb24gPSBCb29sZWFuKHByZWZlcnNSZWR1Y2VkTW90aW9uIHx8IHNob3VsZFJlZHVjZU1vdGlvbik7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6IFwidHdlZW5cIixcbiAgICAgIC4uLnJlZHVjZU1vdGlvbiA/IFJFRFVDRURfTU9USU9OX1RXRUVOX0NPTkZJRyA6IHR3ZWVuQ29uZmlnXG4gICAgfTtcbiAgICBjb25zdCB5ID0gdXNlTW90aW9uVmFsdWUod2luZG93SGVpZ2h0KTtcbiAgICBjb25zdCB6SW5kZXggPSB1c2VUcmFuc2Zvcm0oXG4gICAgICB5LFxuICAgICAgKHZhbHVlKSA9PiB2YWx1ZSArIDIgPj0gd2luZG93SGVpZ2h0ID8gLTEgOiAoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnpJbmRleCkgPz8gOTk5OVxuICAgICk7XG4gICAgY29uc3QgdmlzaWJpbGl0eSA9IHVzZVRyYW5zZm9ybShcbiAgICAgIHksXG4gICAgICAodmFsdWUpID0+IHZhbHVlICsgMiA+PSB3aW5kb3dIZWlnaHQgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCJcbiAgICApO1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHVzZVJlZih7XG4gICAgICBvbk9wZW5TdGFydCxcbiAgICAgIG9uT3BlbkVuZCxcbiAgICAgIG9uQ2xvc2VTdGFydCxcbiAgICAgIG9uQ2xvc2VFbmRcbiAgICB9KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGNhbGxiYWNrcy5jdXJyZW50ID0ge1xuICAgICAgICBvbk9wZW5TdGFydCxcbiAgICAgICAgb25PcGVuRW5kLFxuICAgICAgICBvbkNsb3NlU3RhcnQsXG4gICAgICAgIG9uQ2xvc2VFbmRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgb25EcmFnID0gdXNlU3RhYmxlQ2FsbGJhY2soKF8sIGluZm8pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRZID0geS5nZXQoKTtcbiAgICAgIGlmIChzbmFwUG9pbnRzUHJvcCkge1xuICAgICAgICBjb25zdCBzaGVldEhlaWdodCA9IGdldFNoZWV0SGVpZ2h0KHNoZWV0UmVmKTtcbiAgICAgICAgY29uc3Qgc25hcFBvaW50cyA9IGdldFNuYXBQb2ludHMoeyBzbmFwUG9pbnRzUHJvcCwgc2hlZXRIZWlnaHQgfSk7XG4gICAgICAgIGNvbnN0IHRvcFNuYXBQb2ludCA9IHNoZWV0SGVpZ2h0IC0gc25hcFBvaW50c1swXTtcbiAgICAgICAgaWYgKGluZm8uZGVsdGEueSA8IDAgJiYgY3VycmVudFkgPD0gdG9wU25hcFBvaW50KSB7XG4gICAgICAgICAgeS5zZXQodG9wU25hcFBvaW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0geS5nZXRWZWxvY2l0eSgpO1xuICAgICAgaWYgKHZlbG9jaXR5ID4gMCkgaW5kaWNhdG9yUm90YXRpb24uc2V0KDEwKTtcbiAgICAgIGlmICh2ZWxvY2l0eSA8IDApIGluZGljYXRvclJvdGF0aW9uLnNldCgtMTApO1xuICAgICAgeS5zZXQoTWF0aC5tYXgoY3VycmVudFkgKyBpbmZvLmRlbHRhLnksIDApKTtcbiAgICB9KTtcbiAgICBjb25zdCBvbkRyYWdTdGFydCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmICghZm9jdXNlZEVsZW1lbnQgfHwgIXNoZWV0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IGlzSW5wdXQgPSBmb2N1c2VkRWxlbWVudC50YWdOYW1lID09PSBcIklOUFVUXCIgfHwgZm9jdXNlZEVsZW1lbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiO1xuICAgICAgaWYgKGlzSW5wdXQgJiYgc2hlZXRSZWYuY3VycmVudC5jb250YWlucyhmb2N1c2VkRWxlbWVudCkpIHtcbiAgICAgICAgZm9jdXNlZEVsZW1lbnQuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9uRHJhZ0VuZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChfLCB7IHZlbG9jaXR5IH0pID0+IHtcbiAgICAgIGlmICh2ZWxvY2l0eS55ID4gZHJhZ1ZlbG9jaXR5VGhyZXNob2xkKSB7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNoZWV0SGVpZ2h0ID0gZ2V0U2hlZXRIZWlnaHQoc2hlZXRSZWYpO1xuICAgICAgICBjb25zdCBjdXJyZW50WSA9IHkuZ2V0KCk7XG4gICAgICAgIGxldCB5VG8gPSAwO1xuICAgICAgICBjb25zdCBzbmFwUG9pbnRzID0gc25hcFBvaW50c1Byb3AgPyBnZXRTbmFwUG9pbnRzKHsgc25hcFBvaW50c1Byb3AsIHNoZWV0SGVpZ2h0IH0pIDogdm9pZCAwO1xuICAgICAgICBpZiAoc25hcFBvaW50cykge1xuICAgICAgICAgIGNvbnN0IHsgc25hcFksIHNuYXBJbmRleCB9ID0gZ2V0Q2xvc2VzdFNuYXBQb2ludCh7XG4gICAgICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICAgICAgY3VycmVudFksXG4gICAgICAgICAgICBzaGVldEhlaWdodCxcbiAgICAgICAgICAgIGRldGVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHlUbyA9IHNuYXBZO1xuICAgICAgICAgIG9uU25hcCA9PSBudWxsID8gdm9pZCAwIDogb25TbmFwKHNuYXBJbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFkgLyBzaGVldEhlaWdodCA+IGRyYWdDbG9zZVRocmVzaG9sZCkge1xuICAgICAgICAgIHlUbyA9IHNoZWV0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGUoeSwgeVRvLCBhbmltYXRpb25PcHRpb25zKTtcbiAgICAgICAgaWYgKHlUbyArIDEgPj0gc2hlZXRIZWlnaHQpIHtcbiAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZGljYXRvclJvdGF0aW9uLnNldCgwKTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHNuYXBQb2ludHNQcm9wICYmIG9uU25hcCkge1xuICAgICAgICBvblNuYXAoaXNPcGVuID8gaW5pdGlhbFNuYXAgOiBzbmFwUG9pbnRzUHJvcC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9LCBbaXNPcGVuXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghaXNPcGVuKSByZXR1cm47XG4gICAgICBsZXQgeVRvID0gMDtcbiAgICAgIGlmIChzbmFwUG9pbnRzUHJvcCkge1xuICAgICAgICBjb25zdCBzbmFwSW5kZXggPSBpbml0aWFsU25hcDtcbiAgICAgICAgY29uc3Qgc2hlZXRIZWlnaHQgPSBnZXRTaGVldEhlaWdodChzaGVldFJlZik7XG4gICAgICAgIGNvbnN0IHNuYXBQb2ludHMgPSBnZXRTbmFwUG9pbnRzKHsgc25hcFBvaW50c1Byb3AsIHNoZWV0SGVpZ2h0IH0pO1xuICAgICAgICBjb25zdCBzbmFwWSA9IGdldFNuYXBZKHsgc2hlZXRIZWlnaHQsIHNuYXBQb2ludHMsIHNuYXBJbmRleCB9KTtcbiAgICAgICAgaWYgKHNuYXBZICE9PSBudWxsKSB7XG4gICAgICAgICAgeVRvID0gc25hcFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFuaW1hdGUoeSwgeVRvLCBhbmltYXRpb25PcHRpb25zKTtcbiAgICB9LCBbaXNPcGVuXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XG4gICAgICB5LFxuICAgICAgc25hcFRvOiAoc25hcEluZGV4KSA9PiB7XG4gICAgICAgIGlmICghc25hcFBvaW50c1Byb3ApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTbmFwcGluZyBpcyBub3QgcG9zc2libGUgd2l0aG91dCBgc25hcFBvaW50c2AgcHJvcC5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoZWV0SGVpZ2h0ID0gZ2V0U2hlZXRIZWlnaHQoc2hlZXRSZWYpO1xuICAgICAgICBjb25zdCBzbmFwUG9pbnRzID0gZ2V0U25hcFBvaW50cyh7IHNuYXBQb2ludHNQcm9wLCBzaGVldEhlaWdodCB9KTtcbiAgICAgICAgY29uc3Qgc25hcFkgPSBnZXRTbmFwWSh7IHNoZWV0SGVpZ2h0LCBzbmFwUG9pbnRzLCBzbmFwSW5kZXggfSk7XG4gICAgICAgIGlmIChzbmFwWSAhPT0gbnVsbCkge1xuICAgICAgICAgIGFuaW1hdGUoeSwgc25hcFksIGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgICAgICAgIG9uU25hcCA9PSBudWxsID8gdm9pZCAwIDogb25TbmFwKHNuYXBJbmRleCk7XG4gICAgICAgICAgaWYgKHNuYXBZICsgMSA+PSBzaGVldEhlaWdodCkge1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgICBpZiAocm9vdElkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVGhlIGByb290SWRgIHByb3AgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uIFVzZSBgbW9kYWxFZmZlY3RSb290SWRgIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHVzZU1vZGFsRWZmZWN0KHtcbiAgICAgIHksXG4gICAgICBzaGVldFJlZixcbiAgICAgIHNuYXBQb2ludHNQcm9wLFxuICAgICAgcm9vdElkOiByb290SWQgfHwgbW9kYWxFZmZlY3RSb290SWQsXG4gICAgICBzdGFydFRocmVzaG9sZDogbW9kYWxFZmZlY3RUaHJlc2hvbGRcbiAgICB9KTtcbiAgICB1c2VQcmV2ZW50U2Nyb2xsKHtcbiAgICAgIGlzRGlzYWJsZWQ6IGRpc2FibGVTY3JvbGxMb2NraW5nIHx8ICFpc09wZW5cbiAgICB9KTtcbiAgICBjb25zdCBkcmFnUHJvcHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0IGRyYWdQcm9wczIgPSB7XG4gICAgICAgIGRyYWc6IFwieVwiLFxuICAgICAgICBkcmFnRWxhc3RpYzogMCxcbiAgICAgICAgZHJhZ01vbWVudHVtOiBmYWxzZSxcbiAgICAgICAgZHJhZ1Byb3BhZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgb25EcmFnLFxuICAgICAgICBvbkRyYWdTdGFydCxcbiAgICAgICAgb25EcmFnRW5kXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRpc2FibGVEcmFnID8gdm9pZCAwIDogZHJhZ1Byb3BzMjtcbiAgICB9LCBbZGlzYWJsZURyYWcsIHdpbmRvd0hlaWdodF0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICB5LFxuICAgICAgc2hlZXRSZWYsXG4gICAgICBpc09wZW4sXG4gICAgICBpbml0aWFsU25hcCxcbiAgICAgIGRldGVudCxcbiAgICAgIGluZGljYXRvclJvdGF0aW9uLFxuICAgICAgY2FsbGJhY2tzLFxuICAgICAgZHJhZ1Byb3BzLFxuICAgICAgd2luZG93SGVpZ2h0LFxuICAgICAgYW5pbWF0aW9uT3B0aW9ucyxcbiAgICAgIHJlZHVjZU1vdGlvbixcbiAgICAgIGRpc2FibGVEcmFnXG4gICAgfTtcbiAgICBjb25zdCBzaGVldCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChTaGVldENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgbW90aW9uLmRpdixcbiAgICAgIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgcmVmLFxuICAgICAgICBzdHlsZTogeyAuLi5zdHlsZXMud3JhcHBlciwgekluZGV4LCB2aXNpYmlsaXR5LCAuLi5zdHlsZSB9XG4gICAgICB9LFxuICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KEFuaW1hdGVQcmVzZW5jZSwgbnVsbCwgaXNPcGVuID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFNoZWV0U2Nyb2xsZXJDb250ZXh0UHJvdmlkZXIsIG51bGwsIENoaWxkcmVuLm1hcChcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIChjaGlsZCwgaSkgPT4gY2xvbmVFbGVtZW50KGNoaWxkLCB7IGtleTogYHNoZWV0LWNoaWxkLSR7aX1gIH0pXG4gICAgICApKSA6IG51bGwpXG4gICAgKSk7XG4gICAgaWYgKElTX1NTUikgcmV0dXJuIHNoZWV0O1xuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoc2hlZXQsIG1vdW50UG9pbnQgPz8gZG9jdW1lbnQuYm9keSk7XG4gIH1cbik7XG5TaGVldC5kaXNwbGF5TmFtZSA9IFwiU2hlZXRcIjtcbmZ1bmN0aW9uIHVzZUV2ZW50Q2FsbGJhY2tzKGlzT3BlbiwgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHByZXZPcGVuID0gdXNlUHJldmlvdXMoaXNPcGVuKTtcbiAgY29uc3QgZGlkT3BlbiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGhhbmRsZUFuaW1hdGlvbkNvbXBsZXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAoIWRpZE9wZW4uY3VycmVudCkge1xuICAgICAgKF9iID0gKF9hID0gY2FsbGJhY2tzLmN1cnJlbnQpLm9uT3BlbkVuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgZGlkT3Blbi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgKF9kID0gKF9jID0gY2FsbGJhY2tzLmN1cnJlbnQpLm9uQ2xvc2VFbmQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgIGRpZE9wZW4uY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW2lzT3BlbiwgcHJldk9wZW5dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKCFwcmV2T3BlbiAmJiBpc09wZW4pIHtcbiAgICAgIChfYiA9IChfYSA9IGNhbGxiYWNrcy5jdXJyZW50KS5vbk9wZW5TdGFydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH0gZWxzZSBpZiAoIWlzT3BlbiAmJiBwcmV2T3Blbikge1xuICAgICAgKF9kID0gKF9jID0gY2FsbGJhY2tzLmN1cnJlbnQpLm9uQ2xvc2VTdGFydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgIH1cbiAgfSwgW2lzT3BlbiwgcHJldk9wZW5dKTtcbiAgcmV0dXJuIHsgaGFuZGxlQW5pbWF0aW9uQ29tcGxldGUgfTtcbn1cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHN0YXRlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2b2lkIDApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gc3RhdGU7XG4gIH0pO1xuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbi8vIHNyYy9TaGVldENvbnRhaW5lci50c3hcbnZhciBTaGVldENvbnRhaW5lciA9IGZvcndhcmRSZWYoXG4gICh7IGNoaWxkcmVuLCBzdHlsZSwgY2xhc3NOYW1lID0gXCJcIiwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB5LFxuICAgICAgaXNPcGVuLFxuICAgICAgY2FsbGJhY2tzLFxuICAgICAgc2hlZXRSZWYsXG4gICAgICB3aW5kb3dIZWlnaHQsXG4gICAgICBkZXRlbnQsXG4gICAgICBhbmltYXRpb25PcHRpb25zXG4gICAgfSA9IHVzZVNoZWV0Q29udGV4dCgpO1xuICAgIGNvbnN0IHsgaGFuZGxlQW5pbWF0aW9uQ29tcGxldGUgfSA9IHVzZUV2ZW50Q2FsbGJhY2tzKGlzT3BlbiwgY2FsbGJhY2tzKTtcbiAgICBjb25zdCBoZWlnaHQgPSBkZXRlbnQgPT09IFwiZnVsbC1oZWlnaHRcIiA/IE1BWF9IRUlHSFQgOiB2b2lkIDA7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gZGV0ZW50ID09PSBcImNvbnRlbnQtaGVpZ2h0XCIgPyBNQVhfSEVJR0hUIDogdm9pZCAwO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBtb3Rpb24uZGl2LFxuICAgICAge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZWY6IG1lcmdlUmVmcyhbc2hlZXRSZWYsIHJlZl0pLFxuICAgICAgICBjbGFzc05hbWU6IGByZWFjdC1tb2RhbC1zaGVldC1jb250YWluZXIgJHtjbGFzc05hbWV9YCxcbiAgICAgICAgc3R5bGU6IHsgLi4uc3R5bGVzLmNvbnRhaW5lciwgaGVpZ2h0LCBtYXhIZWlnaHQsIC4uLnN0eWxlLCB5IH0sXG4gICAgICAgIGluaXRpYWw6IHsgeTogd2luZG93SGVpZ2h0IH0sXG4gICAgICAgIGV4aXQ6IHsgeTogd2luZG93SGVpZ2h0LCB0cmFuc2l0aW9uOiBhbmltYXRpb25PcHRpb25zIH0sXG4gICAgICAgIG9uQW5pbWF0aW9uQ29tcGxldGU6IGhhbmRsZUFuaW1hdGlvbkNvbXBsZXRlXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9XG4pO1xuU2hlZXRDb250YWluZXIuZGlzcGxheU5hbWUgPSBcIlNoZWV0Q29udGFpbmVyXCI7XG52YXIgY29uc3RyYWludHMgPSB7IGJvdHRvbTogMCwgdG9wOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9O1xuZnVuY3Rpb24gdXNlRHJhZ0NvbnN0cmFpbnRzKCkge1xuICBjb25zdCBjb25zdHJhaW50c1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzID0gdXNlQ2FsbGJhY2soKCkgPT4gY29uc3RyYWludHMsIFtdKTtcbiAgcmV0dXJuIHsgY29uc3RyYWludHNSZWYsIG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyB9O1xufVxuXG4vLyBzcmMvU2hlZXRDb250ZW50LnRzeFxudmFyIFNoZWV0Q29udGVudCA9IGZvcndhcmRSZWYoXG4gICh7IGNoaWxkcmVuLCBzdHlsZSwgZGlzYWJsZURyYWcsIGNsYXNzTmFtZSA9IFwiXCIsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3Qgc2hlZXRDb250ZXh0ID0gdXNlU2hlZXRDb250ZXh0KCk7XG4gICAgY29uc3Qgc2hlZXRTY3JvbGxlckNvbnRleHQgPSB1c2VTaGVldFNjcm9sbGVyQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29uc3RyYWludHNSZWYsIG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyB9ID0gdXNlRHJhZ0NvbnN0cmFpbnRzKCk7XG4gICAgY29uc3QgZHJhZ1Byb3BzID0gZGlzYWJsZURyYWcgfHwgc2hlZXRTY3JvbGxlckNvbnRleHQuZGlzYWJsZURyYWcgPyB2b2lkIDAgOiBzaGVldENvbnRleHQuZHJhZ1Byb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBtb3Rpb24uZGl2LFxuICAgICAge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZWY6IG1lcmdlUmVmcyhbcmVmLCBjb25zdHJhaW50c1JlZl0pLFxuICAgICAgICBjbGFzc05hbWU6IGByZWFjdC1tb2RhbC1zaGVldC1jb250ZW50ICR7Y2xhc3NOYW1lfWAsXG4gICAgICAgIHN0eWxlOiB7IC4uLnN0eWxlcy5jb250ZW50LCAuLi5zdHlsZSB9LFxuICAgICAgICAuLi5kcmFnUHJvcHMsXG4gICAgICAgIGRyYWdDb25zdHJhaW50czogY29uc3RyYWludHNSZWYsXG4gICAgICAgIG9uTWVhc3VyZURyYWdDb25zdHJhaW50c1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfVxuKTtcblNoZWV0Q29udGVudC5kaXNwbGF5TmFtZSA9IFwiU2hlZXRDb250ZW50XCI7XG52YXIgU2hlZXRIZWFkZXIgPSBmb3J3YXJkUmVmKFxuICAoeyBjaGlsZHJlbiwgc3R5bGUsIGRpc2FibGVEcmFnLCAuLi5yZXN0IH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IHsgaW5kaWNhdG9yUm90YXRpb24sIGRyYWdQcm9wcyB9ID0gdXNlU2hlZXRDb250ZXh0KCk7XG4gICAgY29uc3QgeyBjb25zdHJhaW50c1JlZiwgb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIH0gPSB1c2VEcmFnQ29uc3RyYWludHMoKTtcbiAgICBjb25zdCBfZHJhZ1Byb3BzID0gZGlzYWJsZURyYWcgPyB2b2lkIDAgOiBkcmFnUHJvcHM7XG4gICAgY29uc3QgaW5kaWNhdG9yMVRyYW5zZm9ybSA9IHVzZVRyYW5zZm9ybShcbiAgICAgIGluZGljYXRvclJvdGF0aW9uLFxuICAgICAgKHIpID0+IGB0cmFuc2xhdGVYKDJweCkgcm90YXRlKCR7cn1kZWcpYFxuICAgICk7XG4gICAgY29uc3QgaW5kaWNhdG9yMlRyYW5zZm9ybSA9IHVzZVRyYW5zZm9ybShcbiAgICAgIGluZGljYXRvclJvdGF0aW9uLFxuICAgICAgKHIpID0+IGB0cmFuc2xhdGVYKC0ycHgpIHJvdGF0ZSgkeyAtMSAqIHJ9ZGVnKWBcbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBtb3Rpb24uZGl2LFxuICAgICAge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZWY6IG1lcmdlUmVmcyhbcmVmLCBjb25zdHJhaW50c1JlZl0pLFxuICAgICAgICBzdHlsZTogeyAuLi5zdHlsZXMuaGVhZGVyV3JhcHBlciwgLi4uc3R5bGUgfSxcbiAgICAgICAgLi4uX2RyYWdQcm9wcyxcbiAgICAgICAgZHJhZ0NvbnN0cmFpbnRzOiBjb25zdHJhaW50c1JlZixcbiAgICAgICAgb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW4gfHwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LW1vZGFsLXNoZWV0LWhlYWRlclwiLCBzdHlsZTogc3R5bGVzLmhlYWRlciB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIG1vdGlvbi5zcGFuLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LW1vZGFsLXNoZWV0LWRyYWctaW5kaWNhdG9yXCIsXG4gICAgICAgICAgc3R5bGU6IHsgLi4uc3R5bGVzLmluZGljYXRvciwgdHJhbnNmb3JtOiBpbmRpY2F0b3IxVHJhbnNmb3JtIH1cbiAgICAgICAgfVxuICAgICAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgICBtb3Rpb24uc3BhbixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1tb2RhbC1zaGVldC1kcmFnLWluZGljYXRvclwiLFxuICAgICAgICAgIHN0eWxlOiB7IC4uLnN0eWxlcy5pbmRpY2F0b3IsIHRyYW5zZm9ybTogaW5kaWNhdG9yMlRyYW5zZm9ybSB9XG4gICAgICAgIH1cbiAgICAgICkpXG4gICAgKTtcbiAgfVxuKTtcblNoZWV0SGVhZGVyLmRpc3BsYXlOYW1lID0gXCJTaGVldEhlYWRlclwiO1xudmFyIGlzQ2xpY2thYmxlID0gKHByb3BzKSA9PiAhIXByb3BzLm9uQ2xpY2sgfHwgISFwcm9wcy5vblRhcDtcbnZhciBTaGVldEJhY2tkcm9wID0gZm9yd2FyZFJlZihcbiAgKHsgc3R5bGUgPSB7fSwgY2xhc3NOYW1lID0gXCJcIiwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBDb21wID0gaXNDbGlja2FibGUocmVzdCkgPyBtb3Rpb24uYnV0dG9uIDogbW90aW9uLmRpdjtcbiAgICBjb25zdCBwb2ludGVyRXZlbnRzID0gaXNDbGlja2FibGUocmVzdCkgPyBcImF1dG9cIiA6IFwibm9uZVwiO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb21wLFxuICAgICAge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZWYsXG4gICAgICAgIGNsYXNzTmFtZTogYHJlYWN0LW1vZGFsLXNoZWV0LWJhY2tkcm9wICR7Y2xhc3NOYW1lfWAsXG4gICAgICAgIHN0eWxlOiB7IC4uLnN0eWxlcy5iYWNrZHJvcCwgLi4uc3R5bGUsIHBvaW50ZXJFdmVudHMgfSxcbiAgICAgICAgaW5pdGlhbDogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgIGFuaW1hdGU6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBleGl0OiB7IG9wYWNpdHk6IDAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5TaGVldEJhY2tkcm9wLmRpc3BsYXlOYW1lID0gXCJTaGVldEJhY2tkcm9wXCI7XG52YXIgU2hlZXRTY3JvbGxlciA9IGZvcndhcmRSZWYoXG4gICh7XG4gICAgYXV0b1BhZGRpbmcgPSB0cnVlLFxuICAgIGRpc2FibGVTY3JvbGwgPSBmYWxzZSxcbiAgICBkcmFnZ2FibGVBdCA9IFwidG9wXCIsXG4gICAgY2hpbGRyZW4sXG4gICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICBjbGFzc05hbWUgPSBcIlwiLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgeyB5IH0gPSB1c2VTaGVldENvbnRleHQoKTtcbiAgICBjb25zdCB7IHNldERyYWdFbmFibGVkLCBzZXREcmFnRGlzYWJsZWQgfSA9IHVzZVNoZWV0U2Nyb2xsZXJDb250ZXh0KCk7XG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lRHJhZ1N0YXRlKGVsZW1lbnQpIHtcbiAgICAgIGlmIChkaXNhYmxlU2Nyb2xsKSB7XG4gICAgICAgIHNldERyYWdFbmFibGVkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9ID0gZWxlbWVudDtcbiAgICAgIGNvbnN0IGlzU2Nyb2xsYWJsZTIgPSBzY3JvbGxIZWlnaHQgPiBjbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoIWlzU2Nyb2xsYWJsZTIpIHJldHVybjtcbiAgICAgIGNvbnN0IGlzQXRUb3AgPSBzY3JvbGxUb3AgPD0gMDtcbiAgICAgIGNvbnN0IGlzQXRCb3R0b20gPSBzY3JvbGxIZWlnaHQgLSBzY3JvbGxUb3AgPT09IGNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHNob3VsZEVuYWJsZSA9IGRyYWdnYWJsZUF0ID09PSBcInRvcFwiICYmIGlzQXRUb3AgfHwgZHJhZ2dhYmxlQXQgPT09IFwiYm90dG9tXCIgJiYgaXNBdEJvdHRvbSB8fCBkcmFnZ2FibGVBdCA9PT0gXCJib3RoXCIgJiYgKGlzQXRUb3AgfHwgaXNBdEJvdHRvbSk7XG4gICAgICBpZiAoc2hvdWxkRW5hYmxlKSB7XG4gICAgICAgIHNldERyYWdFbmFibGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXREcmFnRGlzYWJsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgIGRldGVybWluZURyYWdTdGF0ZShldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgIGlmIChyZXN0Lm9uU2Nyb2xsKSByZXN0Lm9uU2Nyb2xsKGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBkZXRlcm1pbmVEcmFnU3RhdGUoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAocmVzdC5vblRvdWNoU3RhcnQpIHJlc3Qub25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsUHJvcHMgPSBpc1RvdWNoRGV2aWNlKCkgPyB7IG9uU2Nyb2xsLCBvblRvdWNoU3RhcnQgfSA6IHZvaWQgMDtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIC4uLnN0eWxlcy5zY3JvbGxlcixcbiAgICAgIC4uLnN0eWxlUHJvcFxuICAgIH07XG4gICAgaWYgKGF1dG9QYWRkaW5nKSB7XG4gICAgICBzdHlsZS5wYWRkaW5nQm90dG9tID0geTtcbiAgICB9XG4gICAgaWYgKGRpc2FibGVTY3JvbGwpIHtcbiAgICAgIHN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBtb3Rpb24uZGl2LFxuICAgICAge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZWYsXG4gICAgICAgIGNsYXNzTmFtZTogYHJlYWN0LW1vZGFsLXNoZWV0LXNjcm9sbGVyICR7Y2xhc3NOYW1lfWAsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICAuLi5zY3JvbGxQcm9wc1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuXG4gICAgKTtcbiAgfVxuKTtcblNoZWV0U2Nyb2xsZXIuZGlzcGxheU5hbWUgPSBcIlNoZWV0U2Nyb2xsZXJcIjtcblxuLy8gc3JjL2luZGV4LnRzeFxudmFyIFNoZWV0MiA9IE9iamVjdC5hc3NpZ24oU2hlZXQsIHtcbiAgQ29udGFpbmVyOiBTaGVldENvbnRhaW5lcixcbiAgSGVhZGVyOiBTaGVldEhlYWRlcixcbiAgQ29udGVudDogU2hlZXRDb250ZW50LFxuICBCYWNrZHJvcDogU2hlZXRCYWNrZHJvcCxcbiAgU2Nyb2xsZXI6IFNoZWV0U2Nyb2xsZXJcbn0pO1xuXG5leHBvcnQgeyBTaGVldDIgYXMgU2hlZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-modal-sheet@4.4.0_motion@12.18.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/react-modal-sheet/dist/index.mjs\n");

/***/ })

};
;